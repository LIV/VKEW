#!/usr/bin/env python3

# MIT License

# Copyright (c) 2023 LIV Inc.

# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:

# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

# Originally based on XREW, the OpenXR Extension Wrangler https://github.com/LIV/XREW

import sys
import xml.etree.ElementTree as ET
from datetime import datetime

def get_indent(x):
	out = ""
	for i in range(x):
		out = out + "\t"
	return out

def write_indent(file, x):
	file.write(get_indent(x))

def get_pfn_name(name):
	return "PFN_" + name

def get_vkew_name(name):
	return "__vkew_" + name

def get_pointer_define(name):
	return "static " + get_pfn_name(name) + " " + get_vkew_name(name) + " = NULL;\n"

#TODO remove the file parameter of the next few functions, it is not needed anymore.
def get_static_ptr_def(file, command):
	return get_pointer_define(command)

def get_instance_static_ptr_load(file, command):
	return get_vkew_name(command) + " = (" + get_pfn_name(command) + ") vkGetInstanceProcAddr(instance, \"" + command + "\" );\n"

def get_device_static_ptr_load(file, command):
	return get_vkew_name(command) + " = (" + get_pfn_name(command) + ") vkGetDeviceProcAddr(device, \"" + command + "\" );\n"
 
def get_static_ptr_forget(file, command):
	return get_vkew_name(command) + " = NULL;\n"

def get_macro_function_stub_call(file, command):
	return "#define " + command + " "+ "VKEW_GET_FUN("+ get_vkew_name(command) + ")" + "\n"

def write_whitespace(file):
	file.write("\n\n")
 
def get_use_platform_macro(platform):
	return "VK_USE_PLATFORM_" + platform.upper()

#TODO pass the indent level to this function? 
def wrap_in_platform_macro(platform, text, indent = 0):
	if platform == "all":
		return get_indent(indent) + text
	else:
		return get_indent(indent) + "#ifdef " + get_use_platform_macro(platform) +"\n" + get_indent(indent+1)+ text + get_indent(indent) + "#endif //" + platform + "\n"
    
def is_vulkan_extension(attrib):
	if attrib == "vulkan":
		return True
	elif attrib == "vulkan,vulkansc":
		return True
	else:
		return False

vkew = open("./vkew.h", "w+")

vkew.write("// This file is autogenerated by VKEW, the Vulkan Extension Wrangler. Do not modify!\n")
vk_registry = ET.parse("./Vulkan-Headers/registry/vk.xml")

vk_root = vk_registry.getroot()

def extract_vulkan_header_version(vk_types):
	for types in vk_types:
		for type in types:
			for type_name_or_comment in type:
				if type_name_or_comment.tag == "name" and type_name_or_comment.text == "VK_HEADER_VERSION":
					return int(type_name_or_comment.tail.strip())
	return 0
vk_header_version = extract_vulkan_header_version(vk_root.findall("types"))
					
vk_instance_commands_to_load = {}
vk_device_commands_to_load = {}
vk_instance_commands_to_load["all"] = []
vk_device_commands_to_load["all"] = []

def has(str, lst):
	for i in range(len(lst)):
		if(lst[i]) == str:
			return True
	return False

vkew.write("// Timestamp : ")
vkew.write(datetime.utcnow().isoformat())
vkew.write("\n")

write_whitespace(vkew)


vkew.write("/*\n")
mit = open("./LICENSE", "r")
vkew.write(mit.read())
mit.close()
vkew.write("*/\n")

write_whitespace(vkew)

vkew.write("#ifndef __vkew_h\n")
vkew.write("#define __vkew_h\n\n")
vkew.write("#include <vulkan/vulkan.h>\n\n")

vkew.write("#ifdef __cplusplus\nextern \"C\"\n{\n#endif\n\n")

#TODO define version tag here

vkew.write("#define VKEW_GET_FUN(x) x\n")
vkew.write("#define VKEW_VK_HEADER_VERSION_GENERATED " + str(vk_header_version) + "\n")

vkew.write("// Some correctness check macros to warn about inconsistant headers\n")
vkew.write("#if (VK_HEADER_VERSION < VKEW_VK_HEADER_VERSION_GENERATED)\n")
vkew.write("#define VKEW_HEADER_CHECK_COMPAT(x) _Pragma(#x)\n")
vkew.write("#else\n")
vkew.write("#define VKEW_HEADER_CHECK_COMPAT(x)\n")
vkew.write("#endif\n")
vkew.write("VKEW_HEADER_CHECK_COMPAT(message \"WARN: VKEW has been generated with a vulkan header version that is superior to the one used to compile this code. This may cause errors or compilation failure.\")\n")

vkew.write("#if (VK_HEADER_VERSION != VKEW_VK_HEADER_VERSION_GENERATED)\n")
vkew.write("#define VKEW_HEADER_CHECK_MATCH(x) _Pragma(#x)\n")
vkew.write("#else\n")
vkew.write("#define VKEW_HEADER_CHECK_MATCH(x)\n")
vkew.write("#endif\n")
vkew.write("VKEW_HEADER_CHECK_MATCH(message \"WARN: VKEW has been generated with a vulkan header version that is different to the one used to compile this code. You might want to regenerate VKEW.h with the matching version to assure you have easy access to all extensions potentially available.\")\n")

write_whitespace(vkew)

vk_extensions = vk_root.findall("extensions")
for ext in vk_extensions[0]:
	if is_vulkan_extension(ext.attrib["supported"]):
		commands = ext[0].findall("command")
		for ext_command in commands:
			platform = "all" # we use "all" as a fake platform name to signal there is no platform attributes
			if "platform" in ext.attrib:
				platform = ext.attrib["platform"]
				if platform not in vk_instance_commands_to_load:
					vk_instance_commands_to_load[platform] = []
				if platform not in vk_device_commands_to_load:
					vk_device_commands_to_load[platform] = []
			if ext.attrib["type"] == "instance":
				vk_instance_commands_to_load[platform].append(ext_command.attrib["name"])
			elif ext.attrib["type"] == "device":
				vk_device_commands_to_load[platform].append(ext_command.attrib["name"])

print("list of all non-core instance (extensions) commands in this version of openvk:")
for platform in vk_instance_commands_to_load:
	for command in vk_instance_commands_to_load[platform]:
		print(" - " + command)
print("list of all non-core device (extensions) commands in this version of openvk:")
for platform in vk_device_commands_to_load:
	for command in vk_device_commands_to_load[platform]:
		print(" - " + command)

vkew.write("// Instance:\n") 
for platform in vk_instance_commands_to_load:
	for command in vk_instance_commands_to_load[platform]:
		vkew.write(wrap_in_platform_macro(platform, get_static_ptr_def(vkew, command)))
  
write_whitespace(vkew)
vkew.write("// Device:\n") 
for platform in vk_device_commands_to_load:
	for command in vk_device_commands_to_load[platform]:
		vkew.write(wrap_in_platform_macro(platform, get_static_ptr_def(vkew, command)))
 
write_whitespace(vkew)
 
#TODO handle vulkan versions?
vkew.write("/// Initialize VKEW. Will load all function pointers accessible via the Vulkan instance.\n")
vkew.write("/// \\param instance A validly created Vulkan instance\n")
vkew.write("static void vkewInitInstance(VkInstance instance)\n")
vkew.write("{\n")
write_indent(vkew, 1)
vkew.write("// Vulkan\n")
for platform in vk_instance_commands_to_load:
	for command in vk_instance_commands_to_load[platform]:
		vkew.write(wrap_in_platform_macro(platform, get_instance_static_ptr_load(vkew, command), 1))
vkew.write("}\n")

write_whitespace(vkew)

vkew.write("/// Initialize VKEW. Will load all function pointers accessible via the Vulkan device.\n")
vkew.write("/// \\param instance A validly created Vulkan device\n")
vkew.write("static void vkewInitDevice(VkDevice device)\n")
vkew.write("{\n")
write_indent(vkew, 1)
vkew.write("// Vulkan\n")
for platform in vk_device_commands_to_load:
	for command in vk_device_commands_to_load[platform]:
		vkew.write(wrap_in_platform_macro(platform, get_device_static_ptr_load(vkew, command), 1))
vkew.write("}\n")

write_whitespace(vkew)

vkew.write("/// Forget about all pointers loaded by VKEW. VKEW loaded comands are unavailable unless vkewInitInstance() and vkewInitDevice() are called again.\n")
vkew.write("/// \\note This function cannot fail.\n")
vkew.write("static void vkewQuit()\n")
vkew.write("{\n")
write_indent(vkew, 1)
vkew.write("// Instance:\n")
for platform in vk_instance_commands_to_load:
	for command in vk_instance_commands_to_load[platform]:
		vkew.write(wrap_in_platform_macro(platform, get_static_ptr_forget(vkew, command), 1))
vkew.write("// Device:\n")
for platform in vk_device_commands_to_load:
	for command in vk_device_commands_to_load[platform]:
		vkew.write(wrap_in_platform_macro(platform, get_static_ptr_forget(vkew, command), 1))
vkew.write("}\n")

write_whitespace(vkew)

vkew.write("// Instance macro stub calls\n")
for platform in vk_instance_commands_to_load:
	for command in vk_instance_commands_to_load[platform]:
 	   vkew.write(wrap_in_platform_macro(platform, get_macro_function_stub_call(vkew, command), 1))
vkew.write("// Instance macro stub calls\n")
for platform in vk_device_commands_to_load:
	for command in vk_device_commands_to_load[platform]:
	    vkew.write(wrap_in_platform_macro(platform, get_macro_function_stub_call(vkew, command), 1))

write_whitespace(vkew)

vkew.write("#ifdef __cplusplus\n}\n#endif\n\n")
vkew.write("#endif // __vkew_h\n")
vkew.close()
print("done!")
